# Typedef
- typedef를 통해 type의 이름을 새로운 별칭으로 정의하고 사용
```C++
typedef int i;

i a = 1;
```
--------------------------------------------
#Define
- define을 통해 상수, 매크로를 정의할 수 있음
```C++
#define <이름> <값>

#define PI 3.14
cout<<PI<<endl;
```
--------------------------------------------
# STL
- STL(Standard Template Libiarary)
    - 자료구조, 함수 등을 제공하는 라이브러리
    - 알고리즘, 컨테이너, 이터레이터, 펑터 이렇게 4가지 제공
## 알고리즘
- 정렬, 탐색 등에 관한 함수로 이뤄져 있음
- sort()가 대표적
## 컨테이너
- C++에서 제공하는 자료구조
- 시퀀스 컨테이너
    - 데이터를 단순히 저장해 놓는 자료구조
    - array, vector, deque, forward_list, list
- 연관 컨테이너
    - 자료가 저장되면서 자동 정렬되는 자료구조
    - set, multiset, multimap
- 정렬되지 않은 연결 컨테이너
    - 자동 정렬이 되지 않는 자료구조
    - unordered_set, unordered_map, unordered_multiset, unordered_multimap
- 컨테이너 어댑터
    - 시퀀스 컨테이너를 이용해 만든자료구조
    - stack, queue(deque로 만듦), prioirty_queue(vector로 만듦)
## 이터레이터
- 정의
    - 컨테이너에 저장된 요소의 주소를 가르키는 개체
    - 주소값을 반환하지 못하며 &*를 통해 한단계 더 거쳐 가리키는 해당 요소의 주소값 반환
- 함수
    - begin: 컨테이너의 시작 위치 반환
    - end: 컨테이너의 끝 다음 위치 반환
    - advance(iterator, cnt): iterator를 cnt까지 증가
- 이터레이터와 포인터 차이
    - 이터레이터는 어떠한 컨테이너의 범위 안에서 일부 요소를 가리키며 해당 요소를 순회할수있는 개체
    - 포인터는 변수의 메모리 주소를 저장하는 개체로 delete를 통해 포인터 제거 가능
- 이터레이터 = 일반화된 포인터?
    - 일반화(generalization)는 공통되는 속성들을 일반적인 개념으로 추상화한 형태
    - 이터레이터는 컨테이너의 구조나 안에 들어있는 요소의 타입과 상관없이 컨테이너에 저장된 데이터를 순화하는 과정을 담당하기 때문에 다른 요소들을 쉽게 탐색할 수 있게 일반화한 장치

## 펑터
- 함수 호출 연산자를 오버로드하는 클래스 인스턴스
---------------------------------------------------------------
# 입력
- 종류
    - scanf
    - cin
    - getline
- getline 사용시 주의점
    - cin은 입력받을 때 개행문자 직전까지 입력 받음
    - 이로인해 중간에 위치한 버퍼에 \n이 남아있음
    - 그래서 getline(cin, a)를 하고 또다시 getline(cin, b)를 하게되면 남아있는 버퍼를 getline이 남아있는 버퍼를 읽어 입력이 종료되면서 b에 원하는 값을 넣을 수 없음
    - 그래서 BufferFlush 같은 빈 값을 사용해 개행문자를 없애준 뒤 사용해야함
    - ex) getline(cin, a); getline(cin, bufferflush); getline(cin, b);
----------------------------------------------------------------------
# 출력
- cout
    - 실수 타입 출력
        - cout<<fixed<< setprecision(자리수);
        - cout fixed<<setprecision(3)<< a; // x.xxx
- printf(a == 1)
    - printf("%d", a);  //1
    - printf("%.3f, a); //1.000
    - printf("%2d", a); //01
    - printf 기반 문자열 출력시 string을 문자열에 대한 포인터(char *)타입으로 바꿔줘야 하기 때문에 string.c_str()을 이용해야 함
    - ex) string str; printf("%s", str.c_str());
------------------------------
# 타입
## void
- 리턴 값이 없음
## char
    - ''작은 따옴표 안에 선언
    - 1Byte 크기 문자열
    - 초기화시 주의점 : char에 아무런 값도 할당하지 않으면 널문자(\0, NULL, 0)로 초기화되는데 이는 빈문자열아니고 문자열의 끝을 나타내는데 사용하는 널문자가 들어감
## string
    - ""큰 따옴표 안에 선언
    - char형 배열
    - string 함수
        - begin: 문자열의 첫번째 요소를 가르키는 이터레이터 반환
        - end: 문자열의 마지막 요소를 가르키는 이터레이터 반환
        - size: 문자열의 사이즈 반환, O(1)
        - insert(위치, 문자열): 원하는 위치에 삽입 가능, O(n)
        - pop_back: 문자열의 끝을 지움, O(1)
        - erase(위치, 크기): 원하는 위치에서 크기만큼의 문자 삭제 가능, O(n)
        - find(문자열): 특정 문자열을 찾아 위치 반환, 없다면 string::nops 반환, 보통 O(n), 최악 O(N*M)
        - substr(위치, 크기): 특정 위치에서 크기만큼 문자열 추출, O(N), 크기를 넣지 않으면 특정 위치에서 끝까지 추출
## bool
- 1Byte true(1), false(0)
## int
- 4Byte 정수
- 표현범위 -2147483648 ~ 2147483647까지 약 20억까지 표현
- int끼리 연산시 실수가 나온다면 소수점 아래 값은 모두 버림
## const
- 수정할 수 없는 변수를 정할 때 쓰임
## Overflow
- 타입의 허용 범위를 넘어갈 때 발생하는 에러
## Underflow
- 오버플로우랑 반대 개념으로 결과값보다 작아지게 만들때 발생
## lnong long
- 8Byte 짜리 정수
- -9223372036854775808~9223372036854775807까지 표현 가능
## float
- 4Byte 실수 타입
- 소수점 아래로 7짜리까지 표현 가능
## double
- 8Byte 실수 타입
- 소수점 아래로 15자리까지 표현 가능
---------------------------------------------------------
# 외워두기
## STL reverse()
    - STL에서 제공해주는 문자열을 거꾸로 뒤집는 함수
    - void타입으로 반환되는 것은 없지만 원본 문자열을 바꿈
    - void reverse(BidirectionlIterator first, BidirectionlIterator  last); 문자열의 시작+원하는 지점과 끝 - 원하는 지점 의 이터레이터를 넣으면 됨
    - reverse(a.begin(), a.end());, reverse(a.begin()+3, a.end());
## split()
    - 문자열을 특정 문자열을 기준으로 쪼개서 배열화 시키는 함수
    - 지원하지 않으므로 직접 구현해야 함
```C++
vector<string> split(const string& input, string delimiter)
{
    vector<string> ret;
    auto start{};
    auto end = input.find(delimiter);

    while(end != string::nops)
    {
        ret.push_back(input.substr(start, end - start));
        start = end + delimiter.size();
        end = input.find(delimiter, start);
    }
    ret.push_back(input.substr(start));
    return ret;
}

int main()
{
    string str = "apple,banana,orange,grape";
    auto ret = split(str, ",");
    
    for(const auto iter : ret)
        cout<<iter<<" ";
}
//결과 : apple banana orange grape
```
## 범위기반 for문
- for(range_declaration : range_expression) loop_statement
- 주의점
    - Array는 변수 크기를 기반으로 런타임시 크기 결정되는 VLA(Variable Length Array)라는 특징을 갖음
    - 그러나 범위기반 for의 범위는 컴파일시 결정
    - 때문에 VLA의 크기 자체가 컴파일 시기에 0 이였다 런타임에 크기가 결정되어 에러 발생
    - 그래서 Array는 컴파일에 결정된 크기로만 범위기반 for문 사용가능
```c++
int main()
{
    int n{};
    cin>>n;
    int a[n];
    memset(a,0,sizeof(a));
    for(int i : a)
        ....
}
//배열의 크기가 런타임중에 결정되므로 for문에서 오류 발생
```
## sizeof
    - C++에서 컴파일 타임 연산자
    - 피연산자의 메모리 크기(바이트 단위)를 반환
    - size_t형으로 반환하는데 이는 부호가 없느 정수형 타입
## atoi(s.c_str)
- 문자열 s를 정수 int로 변환하는 방법
- const char* 타입의 C스타일 문자열을 int로 반환
- 만약 입력값이 정수가 아닌 문자열이라면 0을 반환하고, 그게 아니라면 숫자로 올바르게 변환
## stoi
- atio와 같은 가능을 하는 함수
- const char* 타입이 아닌 string을 받아서 int로 변환
- stoi는 입력값이 정수가 아닌 문자열이라면 에러로 처리되므로 입력받은 글자가 문자열인지 확이하는 로직이 필요하면 atoi를 사용해야함
## pair, tuple
- 타입이나 자료구조가 아님
- pair
    - first, second라는 맴버 변수를 갖는 클래스
    - 두가지 값을 담을 때 사용
    - make_pair(a,b)를 통해 만들 수 있음
    - tie(a,b)를 통해 pair안의 first, second를 a,b에 담을 수 음
- tuple
    - 세가지 이상의 값을 담을 때 사용
    - 값을 꺼낼때 get<0>, get<1>, get<1>이런식으로 꺼내야함
    - tie(a,b,c)를 통해 tuple안의 3개의 값을 a,b,c에 담을 수있음
## auto
- 타입 추론을 하여 결정되는 타입
## 타입 변환
- (바꿀 타입) 기존 변수
- 기존 변수를 바꿀 타입으로 자료형을 변환
- 형변환하고 연산시 값이 달라질 수 있으로 타입을 반드시 맞춰줘야함
## fill, memset
- 배열을 초기화 할때 사용
- fill
    - 모든 값으로 초기화 할 수 있음
    - O(n)
    - fill(시작값(first), 끝값(last), 초기화 하는 값(val))으로 배열에 들어가느 값 초기화
    - 일부 값 초기화 하는 경우도 있지만 보통은 전체를 초기화 함
    - 1차원 배열 : fill(&a[0], &a[10], 100) or fill(&a[0], &a[0] * 10, 100)
    - 2차원 배열 : fill(&a[0][0], &a[9][10], 2) or fill(&a[0][0], &a[0][0]+10*10,2)
    - 전체 초기화 하는 이유는 초기화 시킬때 순차적으로 1행에 있는 요소들 초기화하고 2행,3행 초기화 일어나기 때문에 전부다 초기화 안하면 이전의 값이 남아있을 수 음
- memset
    - 바이트단위로 초기화, -1, 0, char형 으로만 초기화 가능
    - fill보다 빠름
    - void* memset(void * prt, int value, size_t num)으로 배열의 이름, 값, 배열의 크기가 들어감
## memcpy(), copy()
- 둘다 깊은 복사시 사용
    - 깊은 복사: 새로운 메모리 공간을 확보해 복사, 복사한 배열 수정시 원본은 변하지 않음
    - 얕은 복사: 메모리 주소값을 복사한 것, 복사한 배열 수정시 원본도 변함
- memcpy
    - array끼리 복사할때 사용
    - 어떤 변수의 메모리에 있는 값들을 다른 변수의 특정 메모리값으로 복사
    - void* memcpy(void* destination, const void* source, size_t num)
    - memcpy(ret, v, sizeof(v));
    - vector에서는 깊은복사가 안되는데 그 이유는 memcpy는 Trivially Copyable이 타입이 아닌경우 함수 자체가 제대로 작동하지 않기 때문
        - memcpy()의 Trivially Copyable: src가 가리키는 객체로부터 des가 가리키는 객체로 바이트 단위로 count만큼 복사, 객체들이 겹치거나 단순 복사가 가능하지 않은 경우 (이를 Trivially Copyable라 함) 해당 함수는 올바르게 작동하지 않음
    - 주의점
        - 복사하는 배열(src)과 복사되는 대상(dest)의 배열 메모리가 겨치면 UB가 발생
            - UB(Undefined Behavior) : 언어 표준에서 결과를 보장하지 않는 동작
-copy
    - array, vector끼리 복사할때 모두 사용
    - std::copy(InputIterator first, InputIteraor last, OutputIterator result)
    - vector 복사 : copy(v.begin(), v.end(), ret.begin()); - v를 ret에 복사
    - array 복사 : copy(arr, arr+n, ret); - 이때 배열의 크기는 컴파일 시간에 상수여야함
    - 주의! : 복사하는 vector와 복사 당하는 vector의 크기를 맞춰줘야 함!!!
## sort()
- 배열등 컨테이너 요소를 정렬하는 함수
- O(nlogn)
- sort(first, last, *커스텀비교함수): first는 배열의 첫번째 이터레이터, last는 배열의 마지막 이터레이터로 first~ (last-1)의 범위를 갖음
- 배열을 sort할땐 sort(a, a+크기)가 들어가는데 sort에 주소값이 들어가야 되므로...
- 오름차순이 기본으로, greater<타입>()을 넣어 내림차순 변경이 가능
- pair사용시 따로 설정하지 않으면 first, second 순으로 정렬
- 원리
    - 각 요소들을 cmp함수가 true가 뜨는 요소들의 순서로 바꿔줌
    - 즉 true면 바꾸고 하는 식
## stable_sort()
- 들어온 순서대로 정렬하는 방법
- sort에서 같은 값이 들어왔을 때 순서 보장이 안되는데 이를 활용하면 보장이 됨
- ex) pair로 된 배열에서 (2,2), (2,5)가 들어왔을 때 sort는 (2,2), (2,5) 또는 (2,5),(2,2)로 둘다 가능하지만 stable_sort는 (2,2), (2,5)로 들어온 순서 보장
## sort()와 stable_sort() 차이
- sort는 불안정한 알고리즘 사용해 같은 값을 가진 요소들의 들어온 순서 보장 x
- stable_sort는 안정 정렬 알고리즘을 통해 같은 값을 가진 요소들의 들어온 순서 보장 O
## unique()
- 범위안의 있는 요소중 앞에서부터 서로를 비교해가며 중복 요소 제거하고 나머지 요소 삭제하지 않고 그대로 두는 함수
- O(n)
- 반드시 sort와 함께 써야함!!!
    - 앞에서부터 서로를 비교하며 중복된 요소 제거하기 때문
- 나머지 요소 삭제 안하므로 erase와 함께 사용하면 좋음
```C++
int main()
{
    vector<int> v{1, 1, 2, 2, 3, 3, 5, 6, 7, 8, 9};
    unique(v.begin(), v.end());

    vector<int> s{4, 3, 3, 5, 1, 2, 3}
    s.erase(unique(s.begin(), s.end()), s.end());

    vector<int> s2{4, 3, 3, 5, 1, 2, 3}
    s2.erase(unique(s2.begin(), s2.end()), s2.end());
}
//결과 1 2 3 5 6 7 8 9 
//결과 4 3 5 1 2 3
//결과 1 2 3 4 5
```
## lower_bound, upper_bound
- 정렬된 배열에서 어떤 값이 나오는 첫번째 지점 또는 초과하는 지점의 위치를 찾을 때 이분탐색을 이용해 사용하는데 이를 함수로 구현해논것
- 반드시 정렬된 배열에서 사용해야함!!
- lower_bound: lower_bound(firstiterator, lastiterator, value) value가 들어있는 위치의 이터레이터 반환
- upper_bound: upper_bound(firstiterator, lastiterator, value) value를 초과하는 값 들어있는 위치의 이터레이터 반환
- 두 함수 모두 *이터레이터를 하면 안에 들어있는 요소를 가져옴
- 인덱스를 얻기 위해서는 배열의 시작 지점을 빼서 (- 배열.begin()) 해당 위치의 인덱스를 구할 수있음
- upper_bound - lower_bound를 해주면 배열안에  원하는 값의 갯수도 구할 수 있음 
- 만약 해당 요소가 없으면 근방지점을 반환
## accumulate
- 배열의 합을 쉽고 빠르게 구해주는 함수
- accumulate(firstiterator, lastiterator, initvalue)로 배열의 시작, 끝 주소와 초기 시작 값이 들어감
- 초기 시작 값은 해당 값에 배열에 있는 모든 값들의 합이 더해지기 때문에 0으로 많이 사용
## max_element, min_element
- max_element
    - 배열중 가장 큰 요소 추출
    - 이터레이터 반환하기 때문에 *를 사용해 해당 위치의 요소나 최댓값의 인덱스를 뽑아낼 수 있음
- min_element
    - 배열중 가장 작은 요소 추출
    - 이터레이터 반환하기 때문에 *를 사용해 해당 위치의 요소나 최소값의 인덱스를 뽑아낼 수 있음
---------------------------------------------------------
# 포인터
- 포인터의 *는 에스터리스크라 함
- 개념
    - 변수의 메모리 주소를 담는 타입
    - 크기는 어떤 타입이든 상관 없이 32bit라면 4Byte, 64bit라면 8Byte 고정
- 역참조 연산자
    - C++에서 *는 사용하는 위치에 의해 다양한 용도로 사용됨
    - 곱셈 연산, 포인터 선언, 역참조
    - 역참조는 메모리 기반으로 변수의 값에 접근할때 사용
    - 포인터에 *연산자를 통해 역참조를 걸어 주소값을기반으로 값을 끄집어냄
# array to point decay
- 배열의 이름을 주소값으로 사용 가능한데 이는 배열이 포인터로 부식(decay)되는 현상 때문임
- 배열의 이름을 T*라는 포인터에 할당하면 T[N]이란 배열의 크기 정보 N이 없어지고 첫번째 요소의 주소가 바인딩 됨
- 즉 배열의 이름은 배열의 첫번째 주소로 사용 가능
- vector는 안되고 array만 가능
------------------------------------------------------
# 프로세스 메모리 구조와 정적할당과 동적할당
- 메모리 구조
![alt text](image.png)
    - 위에서 부터 스택, 힙, 데이터영역(BSS segment, Data segment), 코드영역
    - 스택은 위 주소부터, 힙은 아래 주소부터 할당
    - 스택: 지역변수, 매개변수, 함수가 저장되고 컴파일 시 크기 결정[동적인 특징]
    - 힙 : 동적할당 때 사용, 런타임시 크기 결정[동적인 특징]
    - 데이터 영역: BSS, Data영역으로 나뉘고 정적 할당에 관한 부분 담담[정적인 특징]
    - 코드 영역 : 소스코드 들어감[정적인 특징]
- BSS segment: 전역변수, static, const로 선언되어 있는 변수 중 0또는 어떤 값으로 초기화가 되어있지 않은 변수들
- Data segment: 전역변수, static, const로 선언되어 있느 변수 중 0이아닌 값으로 초기화된 변수들
103p 메모리주소끼리의 뺄셈